# 1/3

Разберём все методы класса json::Builder. 
Ниже описана их семантика, и для понимания дан контекст, в котором они вызываются. 
Ошибки неверного использования методов, которые должны обрабатываться в вашей реализации, буду разобраны ниже.

    Key(std::string). При определении словаря задаёт строковое значение ключа для очередной пары ключ-значение. 
    Следующий вызов метода обязательно должен задавать соответствующее этому ключу значение с помощью метода Value 
    или начинать его определение с помощью StartDict или StartArray.

    Value(Node::Value). Задаёт значение, соответствующее ключу при определении словаря, очередной элемент массива 
    или, если вызвать сразу после конструктора json::Builder, всё содержимое конструируемого JSON-объекта. 
    Может принимать как простой объект — число или строку — так и целый массив или словарь.
    Здесь Node::Value — это синоним для базового класса Node, шаблона variant с набором возможных типов-значений. 
    Смотрите заготовку кода.

    StartDict(). Начинает определение сложного значения-словаря. 
    Вызывается в тех же контекстах, что и Value. 
    Следующим вызовом обязательно должен быть Key или EndDict.

    StartArray(). Начинает определение сложного значения-массива. 
    Вызывается в тех же контекстах, что и Value.
    Следующим вызовом обязательно должен быть EndArray или любой, задающий новое значение: 
    Value, StartDict или StartArray.

    EndDict(). Завершает определение сложного значения-словаря. 
    Последним незавершённым вызовом Start* должен быть StartDict.

    EndArray(). Завершает определение сложного значения-массива. 
    Последним незавершённым вызовом Start* должен быть StartArray.

    Build(). Возвращает объект json::Node, содержащий JSON, описанный предыдущими вызовами методов.
    К этому моменту для каждого Start* должен быть вызван соответствующий End*. 
    При этом сам объект должен быть определён, то есть вызов json::Builder{}.Build() недопустим.

    Возвращаемое значение каждого метода, кроме Build, должно быть Builder&.

    Описанный синтаксис позволяет указывать ключи словаря в определённом порядке. 
    Тем не менее, в данном случае это учитывать не нужно. 
    Словари всё так же должны храниться с помощью контейнера map.

При реализации обратите внимание на метод emplace_back у вектора: 
в отличие от push_back он принимает не сам добавляемый объект, а аргументы конструктора этого объекта. 
Иногда это может быть удобно.

/--- Обработка ошибок ---/
В случае использования методов в неверном контексте ваш код должен выбросить исключение типа std::logic_error с понятным сообщением об ошибке.
Это должно происходить в следующих ситуациях:

    Вызов метода Build при неготовом описываемом объекте, то есть сразу после конструктора или при незаконченных массивах и словарях.
    Вызов любого метода, кроме Build, при готовом объекте.
    Вызов метода Key снаружи словаря или сразу после другого Key.
    Вызов Value, StartDict или StartArray где-либо, кроме как после конструктора, после Key или после предыдущего элемента массива.
    Вызов EndDict или EndArray в контексте другого контейнера.

/--- Подсказки ---/
Мы рекомендуем хранить в объекте json::Builder следующее состояние:

    Node root_; — сам конструируемый объект.
    std::vector<Node*> nodes_stack_; — стек указателей на те вершины JSON, которые ещё не построены: 
    то есть текущее описываемое значение и цепочка его родителей. 
    Он поможет возвращаться в нужный контекст после вызова End-методов.

Начните проектирование кода с описания ожидаемого состояния класса (в первую очередь — последней вершины в стеке) 
для каждой точки в цепочке вызовов в примере.

# 2/3
/--- Задача ---/
Улучшите класс json::Builder так, чтобы некоторые явные ошибки находились на этапе компиляции, 
а не выбрасывались в виде исключений при запуске программы. 
Ловить так все ошибки — сложная задача. 
Вы решите её в следующих спринтах, а пока начнёте с простого.

Код работы с обновлённым json::Builder не должен компилироваться в следующих ситуациях:

    Непосредственно после Key вызван не Value, не StartDict и не StartArray.
    После вызова Value, последовавшего за вызовом Key, вызван не Key и не EndDict.
    За вызовом StartDict следует не Key и не EndDict.
    За вызовом StartArray следует не Value, не StartDict, не StartArray и не EndArray.
    После вызова StartArray и серии Value следует не Value, не StartDict, не StartArray и не EndArray.

/--- Подсказки ---/
На одном примере разберём, как гарантировать, что после StartDict вызывается Key или EndDict. 
Верните из метода StartDict объект вспомогательного класса DictItemContext со следующими свойствами:

    хранит ссылку на Builder;
    поддерживает только методы Key и EndDict, делегируемые в Builder.

Чтобы избежать дублирования кода с делегированием, удобно использовать наследование.

# 3/3
/--- Задача ---/
Возьмите решение финального проекта десятого спринта и интегрируйте в него написанный вами json::Builder: 
каждый раз, когда формируете ответ на запрос, используйте для этого новый класс.

/--- Подсказки ---/
Если формируете JSON-ответ по частям, для передачи этих частей используйте json::Node или json::Dict.
Во втором случае после Build понадобится вызвать AsDict.